#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_scalar_block_layout : enable

#define TEXTURE_ALIGN 16

#define pos_to_px(pos) (vec2(pos.x, pos.y + (pos.z * TEXTURE_ALIGN)))

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0) uniform sampler2D brick_texture;
layout (set = 1, binding = 0, rgba8) uniform image2D out_brick_texture;

layout(push_constant) uniform PushConstant {
    uint px_per_group;
} constant;

vec2 min_texel;
vec2 max_texel;

vec2 get_neighbor(vec2 base_texel, vec3 neighbor_pos) {
    float z_comp = neighbor_pos.z * TEXTURE_ALIGN;
    float z_with_texel_pos = base_texel.y + z_comp;

    z_comp =
        float(step(max_texel.y, z_with_texel_pos)) *
        float(step(z_with_texel_pos, min_texel.y)) *
        z_comp;

    vec2 new_texel = base_texel + vec2(neighbor_pos.x, neighbor_pos.y + z_comp);
    return clamp(new_texel, min_texel, max_texel);
}

void compare_neighbor(vec3 check_neighbor, vec2 base_texel, inout float cur_dist) {
    vec2 texel = get_neighbor(base_texel, check_neighbor);
    vec4 val = texelFetch(brick_texture, ivec2(texel), 0);

    // neighbor is full or stored distance
    float dist = val.x > 0.0 ? 1 : val.w * 256.0 + 1;

    // get smallest value
    cur_dist = min(cur_dist, dist);
}

void main() {
    vec2 group_pos = vec2(gl_GlobalInvocationID.xy);
    vec2 base_texel = group_pos * float(constant.px_per_group) + vec2(constant.px_per_group);

    float min_x = floor(base_texel.x / TEXTURE_ALIGN);
    float min_y = floor(base_texel.y / (TEXTURE_ALIGN * TEXTURE_ALIGN));

    min_texel = vec2(min_x, min_y);
    max_texel = vec2(min_x + TEXTURE_ALIGN, min_y + TEXTURE_ALIGN * TEXTURE_ALIGN);

    vec4 val = texelFetch(brick_texture, ivec2(base_texel), 0);

    float cur_dist = val.w * 256.0;

    // loop gonna be unrolled cuz more fast
    compare_neighbor(vec3(-1, -1, -1), base_texel, cur_dist);
    compare_neighbor(vec3(0, -1, -1), base_texel, cur_dist);
    compare_neighbor(vec3(1, -1, -1), base_texel, cur_dist);

    compare_neighbor(vec3(-1, -1, 0), base_texel, cur_dist);
    compare_neighbor(vec3(0, -1, 0), base_texel, cur_dist);
    compare_neighbor(vec3(1, -1, 0), base_texel, cur_dist);

    compare_neighbor(vec3(-1, -1, 1), base_texel, cur_dist);
    compare_neighbor(vec3(0, -1, 1), base_texel, cur_dist);
    compare_neighbor(vec3(1, -1, 1), base_texel, cur_dist);


    compare_neighbor(vec3(-1, 0, -1), base_texel, cur_dist);
    compare_neighbor(vec3(0, 0, -1), base_texel, cur_dist);
    compare_neighbor(vec3(1, 0, -1), base_texel, cur_dist);

    compare_neighbor(vec3(-1, 0, 0), base_texel, cur_dist);

    compare_neighbor(vec3(1, 0, 0), base_texel, cur_dist);

    compare_neighbor(vec3(-1, 0, 1), base_texel, cur_dist);
    compare_neighbor(vec3(0, 0, 1), base_texel, cur_dist);
    compare_neighbor(vec3(1, 0, 1), base_texel, cur_dist);


    compare_neighbor(vec3(-1, 1, -1), base_texel, cur_dist);
    compare_neighbor(vec3(0, 1, -1), base_texel, cur_dist);
    compare_neighbor(vec3(1, 1, -1), base_texel, cur_dist);

    compare_neighbor(vec3(-1, 1, 0), base_texel, cur_dist);
    compare_neighbor(vec3(0, 1, 0), base_texel, cur_dist);
    compare_neighbor(vec3(1, 1, 0), base_texel, cur_dist);

    compare_neighbor(vec3(-1, 1, 1), base_texel, cur_dist);
    compare_neighbor(vec3(0, 1, 1), base_texel, cur_dist);
    compare_neighbor(vec3(1, 1, 1), base_texel, cur_dist);

    imageStore(out_brick_texture, ivec2(group_pos), vec4(val.xyz, cur_dist / 256.0));
}