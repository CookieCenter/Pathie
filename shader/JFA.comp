#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_scalar_block_layout : enable

#define TEXTURE_ALIGN 16

#define pos_to_px(pos) (vec2(pos.x, pos.y + (pos.z * TEXTURE_ALIGN)))
#define get_neighbor(tex_coord, pos) (tex_coord + pos_to_px(pos))

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0) uniform sampler2D brick_texture;
layout (set = 1, binding = 0, rgba8) uniform image2D out_brick_texture;

layout (set = 2, binding = 0) uniform JFA {
    vec2 px_per_group;
} jfa_buffer;


// get minimum value in which it could go
// without hitting anything in any direction
// todo: edit description
float get_distance(vec3 pos, vec3 point) {
    vec3 dist = abs(point - pos);
    vec3 relevant_component = vec3(lessThan(dist, min(dist.yzx, dist.zxy)));
    return dot(dist, relevant_component);
}

void compare_neighbor(vec3 own_pos, vec3 check_n, vec2 base_texel, inout vec3 cur_near, inout float cn_dist) {
    vec2 texel = get_neighbor(base_texel, check_n);
    vec4 val = texelFetch(brick_texture, ivec2(base_texel), 0);

    // check if there is no val
    if (!(val.x > 0.0)) {
        return;
    }

    // the full neighbor of neighbor
    vec3 n_full = val.xyz;
    // get corresponding distance
    float n_dist = get_distance(own_pos, n_full);

    if (n_dist < cn_dist) {
        cn_dist = n_dist;
        cur_near = n_full;
    }
}

void main() {
    vec2 group_pos = vec2(gl_GlobalInvocationID.xy);
    vec2 base_texel = group_pos * jfa_buffer.px_per_group;

    float z_comp = floor(base_texel.y / TEXTURE_ALIGN);
    vec3 base_pos = vec3(base_texel.x, base_texel.y - z_comp, z_comp);

    vec4 val = texelFetch(brick_texture, ivec2(base_texel), 0);

    // maybe store in component 1, 2, 3 pos and in 4 distance
    // great idea !!!

    // get current nearest and corresponding distance
    vec3 cur_near = val.xyz;
    float cur_dist = val.w;

    // loop gonna be unrolled cuz more fast
    compare_neighbor(base_pos, vec3(-1, -1, -1), base_texel, cur_near, cur_dist);

    imageStore(out_brick_texture, ivec2(group_pos), vec4(cur_near, cur_dist));
}