#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_scalar_block_layout : enable

#define TEXTURE_ALIGN 16

#define pos_to_px(pos) (vec2(pos.x, pos.y + (pos.z * TEXTURE_ALIGN)))

// tex = texel, cs = cube_start or min_texel
#define get_depth_comp(tex, cs) (floor((tex.y - cs.y) / TEXTURE_ALIGN))

// tex = texel, cs = cube_start or min_texel, dc = depth_component
#define px_to_pos(tex, cs, dc) (vec3(tex - cs - vec2(0, dc * TEXTURE_ALIGN), dc))

layout (local_size_x = 1, local_size_y = 1) in;
layout (set = 0, binding = 0) uniform sampler2D brick_texture;
layout (set = 1, binding = 0, rgba8) uniform image2D out_brick_texture;

layout(push_constant) uniform PushConstant {
    uint px_per_group;
} constant;

vec2 min_texel;
vec2 max_texel;

vec3 base_pos;

void compare_neighbor(vec3 check_neighbor, vec2 base_texel, inout float cur_dist, float neighbour_dist, inout vec3 dtn) {
    // potential computed seed location also known as neighbour position
    vec3 neighbour_pos = clamp(base_pos + check_neighbor, vec3(0), vec3(TEXTURE_ALIGN));
    vec4 val = texelFetch(brick_texture, ivec2(pos_to_px(neighbour_pos) + min_texel), 0);

    // potential stored seed location
    vec3 potential_stored_seed = val.xyz * 256.0;

    vec3 dir_to_neighbour = abs(neighbour_pos - base_pos);

    vec3 dir_to_pss = (val.w * 256.0) > 15.0 ? vec3(TEXTURE_ALIGN) : abs(potential_stored_seed - base_pos);

    // neighbor is full then use neighbour position or stored distance
    // direction to seed
    vec3 dts = val.w == 0.0 ? dir_to_neighbour : dir_to_pss;
    dtn = val.w == 0.0 ? dir_to_neighbour : dir_to_pss;

    // relevant component, smallest component of x,y,z
    vec3 rc = vec3(lessThan(dts, min(dts.yzx, dts.zxy)));
    // dot from distance to seed and relevant component -> smallest distance
    float dist = dot(dts, rc);

    // get smallest value
    cur_dist = min(cur_dist, dist);

    // for future developers who get to work on this, please
    // rework the arguments / params of function and try to minimize complex code
    // so tl;dr just make it simple :)
}

void main() {
    vec2 group_pos = vec2(gl_GlobalInvocationID.xy);
    vec2 base_texel = group_pos * float(constant.px_per_group) + vec2(floor(float(constant.px_per_group) / 2.0 + 1.0) - 1.0);

    float min_x = floor(base_texel.x / TEXTURE_ALIGN) * TEXTURE_ALIGN;
    float min_y = floor(base_texel.y / (TEXTURE_ALIGN * TEXTURE_ALIGN)) * TEXTURE_ALIGN * TEXTURE_ALIGN;

    min_texel = vec2(min_x, min_y);
    max_texel = vec2(min_x + TEXTURE_ALIGN, min_y + TEXTURE_ALIGN * TEXTURE_ALIGN);

    float depth_comp = get_depth_comp(base_texel, min_texel);
    base_pos = px_to_pos(base_texel, min_texel, depth_comp);

    vec4 val = texelFetch(brick_texture, ivec2(base_texel), 0);

    float cur_dist = val.w * 256.0;
    int k = int(floor(float(constant.px_per_group) / 2.0 + 1.0));
    vec3 direction_to_nearest = vec3(TEXTURE_ALIGN);

    /*
    for (int x; x < 3; x++) {
        for (int y; y < 3; y++) {
            for (int z; z < 3; z++) {
                compare_neighbor(vec3((x - 1) * k, (y - 1) * k, (z - 1) * k), base_texel, cur_dist, k, direction_to_nearest);
            }
        }
    }
    */

    // loop gonna be unrolled cuz more fast
    compare_neighbor(vec3(-1, -1, -1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(0, -1, -1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(1, -1, -1) * k, base_texel, cur_dist, k, direction_to_nearest);

    compare_neighbor(vec3(-1, -1, 0) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(0, -1, 0) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(1, -1, 0) * k, base_texel, cur_dist, k, direction_to_nearest);

    compare_neighbor(vec3(-1, -1, 1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(0, -1, 1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(1, -1, 1) * k, base_texel, cur_dist, k, direction_to_nearest);


    compare_neighbor(vec3(-1, 0, -1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(0, 0, -1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(1, 0, -1) * k, base_texel, cur_dist, k, direction_to_nearest);

    compare_neighbor(vec3(-1, 0, 0) * k, base_texel, cur_dist, k, direction_to_nearest);

    compare_neighbor(vec3(1, 0, 0) * k, base_texel, cur_dist, k, direction_to_nearest);

    compare_neighbor(vec3(-1, 0, 1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(0, 0, 1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(1, 0, 1) * k, base_texel, cur_dist, k, direction_to_nearest);


    compare_neighbor(vec3(-1, 1, -1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(0, 1, -1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(1, 1, -1) * k, base_texel, cur_dist, k, direction_to_nearest);

    compare_neighbor(vec3(-1, 1, 0) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(0, 1, 0) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(1, 1, 0) * k, base_texel, cur_dist, k, direction_to_nearest);

    compare_neighbor(vec3(-1, 1, 1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(0, 1, 1) * k, base_texel, cur_dist, k, direction_to_nearest);
    compare_neighbor(vec3(1, 1, 1) * k, base_texel, cur_dist, k, direction_to_nearest);

    bool not_seed = val.w != 0.0;
    cur_dist *= float(not_seed);
    direction_to_nearest = not_seed ? direction_to_nearest : val.xyz * 256.0;

    imageStore(out_brick_texture, ivec2(base_texel), vec4(direction_to_nearest / 256.0, cur_dist / 256.0));
}