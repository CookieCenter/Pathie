#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_scalar_block_layout : enable

#define maxDepth 17
#define maxDistance 4096.0
#define maxSearchDepth 300

#define sqr(number) (number * number)
#define rot(spin) mat2(cos(spin), sin(spin), - sin(spin), cos(spin))
#define dir(rot) vec3(cos(rot.x) * cos(rot.y), sin(rot.y), sin(rot.x) * cos(rot.y))
#define rad(degree) vec2(3.14 * degree / 180.0)

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

layout (std430, set = 1, binding = 0) uniform Uniform {
    vec4 pos;

    vec2 res;
    vec2 mouse;

    float rootSpan;

    uint time;
} uniformBuffer;

struct TreeNode {
    uint children[8];

    // 0 = empty | 1 = subdivide | 2 = full
    uint nodeType;
    uint parent;
    vec4 baseColor; // ToDo -> Add transparency
};

layout (std430, set = 2, binding = 0) buffer OctreeData { TreeNode octreeData[40000]; };

struct Light {
    vec4 pos;
    uint index;
};

layout (set = 3, binding = 0) readonly buffer LightData { Light lightData[2000]; };


struct Ray {
    vec3 origin;
    vec3 dir;

    vec3 invRayDir; // Used for RayCube Intersection
};

// Position in Octree
struct PosInfo {
    vec3 maskInParent[maxDepth]; // Offset of array wrong

    vec3 localPos; // Position within current Cell / Node
    vec3 posOnEdge; // RayOrigin on the Edge of the Node

    uint index;
    float span;
    int depth;

    bool parentEdge; // Should move upward
};

struct Intersection {
    bool intersect;
    float dist;
    PosInfo info;
};

struct TraverseProp {
    // Max
    uint depth;
    float dist;
    uint searchDepth;
};

// RayCube Intersection on inside of Cube
vec3 rayCubeIntersect(vec3 origin, vec3 dir, vec3 invDir, float span) {
    return - (sign(dir) * (origin - span * 0.5) - span * 0.5) * invDir;
}

// Simple Hashing Scheme
uint maskToIndex(vec3 mask) {
    return uint(mask.x + mask.y * 4.0 + mask.z * 2.0);
}

void main() {
    imageStore(computeImage, ivec2(gl_GlobalInvocationID.xy), vec4(0));
}