# version 450
# extension GL_ARB_separate_shader_objects : enable
# extension GL_ARB_shading_language_420pack : enable
# extension GL_EXT_debug_printf : enable

# define PI 3.141592654

# define OCTREE_MAX_NODE 2000
# define MAX_SEARCH_DEPTH 8

const uint[3][8] ADJACENT_NODE_LIST = uint[3][8](
		uint[3](1, 4, 2),
		uint[3](0, 5, 3),
		uint[3](3, 6, 0),
		uint[3](2, 7, 1),

		uint[3](5, 0, 6),
		uint[3](4, 1, 7),
		uint[3](7, 2, 4),
		uint[3](6, 3, 5),
	);

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

layout (set = 1, binding = 0) uniform UniformBuffer {
	uint time;

	float rawfieldOfView;
	uint maxRayLen;

	float rotHorizontal;
	float rotVertical;

	uint octreeRootIndex; 
	
	uint nodeAtPos;
	float X;
	float Y;
	float Z;
} uniformBuffer;

struct TreeNode {
	uint mat;
	uint parent;
	uint[8] children;
	uint spaceIndex;
	float span;

	float X;
	float Y;
	float Z;
};

layout (set = 2, binding = 0) readonly buffer OctreeData {
	TreeNode[OCTREE_MAX_NODE] octreeData;
};

layout (set = 3, binding = 0) readonly buffer GraphicPref {
	uint empty;
} graphicPref;

uint posToIndex(vec3 pos, float sideLen) {
	return uint(pos.x + pos.y * sideLen * sideLen + pos.z * sideLen);
}

vec3 getOuterPos(in vec3 innerPos, in vec3 dir, in float diameter) {
	return innerPos + (dir * diameter);
}

// 1 = inside | 0 = outside
float inRange(in float first, in float sec, in float check) {
    return step(min(first, sec), check) - step(max(first, sec), check);
}

// 1 = inside | 0 = outside
float betweenVectorGroup(in vec3 first, in vec3 sec, in vec3 vector) {
    vec3 stepVector = step(min(first, sec), vector) - step(max(first, sec), vector);
    return stepVector.x * stepVector.y * stepVector.z;
}

float checkPosInNode(TreeNode node, vec3 checkPos) {
	vec3 bottomLeft = getOuterPos(vec3(node.X, node.Y, node.Z), vec3(-1, -1, -1), node.span / 2.0);
	vec3 topRight = getOuterPos(vec3(node.X, node.Y, node.Z), vec3(1, 1, 1), node.span / 2.0);
	
	return betweenVectorGroup(bottomLeft, topRight, checkPos);
}

void updateVox(in uint nextIndex, inout uint curIndex, inout TreeNode curVox) {
	curIndex = nextIndex;
	curVox = octreeData[nextIndex];
}

uint getNextVox(in uint curIndex, in vec3 nextPos, in ivec3 dir) {
	TreeNode curVox = octreeData[curIndex];

	int selectedDir = dir.x * 0 + dir.y * 1 + dir.z * 2;

	vec3 bottomLeft = vec3(0, 0, 0);
	vec3 topRight = vec3(0, 0, 0);
	float nextPosInParent = 0.0;
	
	uint adjacentNode = 0;
	
	uint curLev = 0;
	uint[MAX_SEARCH_DEPTH] levSpaceIndex;

	vec3 childPos = vec3(0, 0, 0);

	// Check if nextPos is in Parent -> If not, curVox = curVox.parent
	for (curLev = 1; curLev < MAX_SEARCH_DEPTH; curLev += 1) {
		nextPosInParent = checkPosInNode(curVox, nextPos);
		if (nextPosInParent > 0.0) { break; }
		else {
			updateVox(curVox.parent, curIndex, curVox);
			levSpaceIndex[curLev] = curVox.spaceIndex;
		}
	}

	if (gl_GlobalInvocationID.xy == uvec2(1,1)) {
		debugPrintfEXT("\n%d %d", curIndex, curLev);
	}
	
	// Select Unspecific Neighbor
	adjacentNode = ADJACENT_NODE_LIST[curVox.spaceIndex][selectedDir];
	updateVox(octreeData[curVox.parent].children[adjacentNode], curIndex, curVox);

	// Select childNode based on recent visited Level
	for (curLev -= 1; curLev > -1; curLev -= 1) {
		if (curVox.children == uint[8](0, 0, 0, 0, 0, 0, 0, 0)) { break; }
		else {
			adjacentNode = ADJACENT_NODE_LIST[levSpaceIndex[curLev]][selectedDir];
			updateVox(curVox.children[adjacentNode], curIndex, curVox);
		}
	}

	// Select childNode based on Position <- No recent visit on curLev
	for (int iter = 0; iter < MAX_SEARCH_DEPTH; iter += 1) {
		if (curVox.children == uint[8](0, 0, 0, 0, 0, 0, 0, 0)) { break; }
		else {
			// Generate childPos -> Check in which Vox [ 0 / 1 ] nextPos is in, for each Direction
			childPos = vec3(
				inRange(curVox.X, curVox.X + curVox.span / 2.0, nextPos.x),
				inRange(curVox.Y, curVox.Y + curVox.span / 2.0, nextPos.y),
				inRange(curVox.Z, curVox.Z + curVox.span / 2.0, nextPos.z)
			);

			updateVox(curVox.children[posToIndex(childPos, 2.0)], curIndex, curVox);
		}
	}

	return curIndex;
}

float getDistanceNext(in float voxCenter, in float dir, in float voxSpan, in float pos) {
	return voxCenter + (voxSpan * sign(dir)) - (pos * sign(dir));
}

void castRay(in vec2 dir, inout uint curIndex, inout vec3 curPos, out float len, out int voxAtPos) {
	TreeNode curVox = octreeData[curIndex];

	// Convert Degree into Radiant
	float alpha = dir.x * PI / 180.0;
	float beta = dir.y * PI / 180.0;
	
	// Create Unit Vector with [ Time = 1 ]
	vec3 unit = vec3(abs(cos(alpha) * cos(beta)) * sign(sin(alpha)), sin(beta), abs(sin(alpha) * cos(beta)) * sign(cos(alpha)));

	vec3 distNextVox = vec3(0, 0, 0);
	vec3 lengthCertainDir = vec3(0, 0, 0);

	float selectedLen = 0;
	float inCurNode = 0;

	uint nodeWithChild = 0;

	ivec3 posBefore = ivec3(0, 0, 0);
	ivec3 posDiff = ivec3(0, 0, 0);

	for (int iter = 0; iter < uniformBuffer.maxRayLen; iter += 1) {
		posBefore = ivec3(curPos);

		distNextVox = vec3(getDistanceNext(curVox.X, unit.x, curVox.span, curPos.x), getDistanceNext(curVox.Y, unit.y, curVox.span, curPos.y), getDistanceNext(curVox.Z, unit.z, curVox.span, curPos.z));
		// Compute Time for each Direction
		lengthCertainDir = vec3(abs(distNextVox.x / unit.x), abs(distNextVox.y / unit.y), abs(distNextVox.z / unit.z));
		// Select most efficient Direction
		selectedLen = min(lengthCertainDir.z, min(lengthCertainDir.x, lengthCertainDir.y));
		// Apply Time to each Direction
		curPos += vec3(unit.x * selectedLen, unit.y * selectedLen, unit.z * selectedLen);

		len += selectedLen;
		// Compute difference between Position [ before / after ] and use as Direction
		posDiff = ivec3(curPos) - posBefore;

		curIndex = getNextVox(curIndex, curPos, posDiff);

		curVox = octreeData[curIndex];
		if (curVox.mat > 0) { break; }
	}
}

vec2 getFieldOfView(in vec2 imageSize) {
	return vec2((imageSize.y / imageSize.x) * uniformBuffer.rawfieldOfView, uniformBuffer.rawfieldOfView);
}

vec2 getCameraDirection(in vec2 imageSize, in vec2 pixelCoord) {
	vec2 fieldOfView = getFieldOfView(imageSize);

	float horizontalDegree = (fieldOfView.x / imageSize.x) * pixelCoord.x - fieldOfView.x / 2;
	float verticalDegree = (fieldOfView.y / imageSize.y) * pixelCoord.y - fieldOfView.y / 2;	

	return vec2(horizontalDegree, verticalDegree);
}

void main () {
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imageSize = ivec2(gl_NumWorkGroups.xy);
	
	vec3 curPos = vec3(uniformBuffer.X, uniformBuffer.Y, uniformBuffer.Z);
	vec2 dir = getCameraDirection(vec2(imageSize * 16), vec2(pixelCoord));
	uint curIndex = uniformBuffer.nodeAtPos;
	float len = 0;
	int voxAtPos = 0;

	castRay(dir, curIndex, curPos, len, voxAtPos);

	// debugPrintfEXT("");

	if (gl_GlobalInvocationID.xy == uvec2(1,1)) {
		// debugPrintfEXT("\n%f", sin(90.0 * PI / 180.0));
	}

	imageStore(computeImage, pixelCoord, vec4(1 - len / uniformBuffer.maxRayLen, 0, 0, 0));
}
