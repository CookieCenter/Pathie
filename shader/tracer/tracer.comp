# version 450
# extension GL_ARB_separate_shader_objects : enable
# extension GL_ARB_shading_language_420pack : enable
# extension GL_EXT_debug_printf : enable

# define PI 3.141592654

# define OCTREE_MAX_NODE 2000

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

layout (set = 1, binding = 0) uniform UniformBuffer {
	uint time;

	float rawfieldOfView;
	float imgCamDistance;
	uint maxRayLen;

	float rotHorizontal;
	float rotVertical;

	uint octreeRootIndex;
	uint maxSearchDepth;
	
	uint nodeAtPos;
	float X;
	float Y;
	float Z;
} uniformBuffer;

struct TreeNode {
	uint parent;
	uint[8] children;
	uint spaceIndex;
	uint span;

	float X;
	float Y;
	float Z;
}

layout (set = 2, binding = 0) readonly buffer OctreeData {
	TreeNode[OCTREE_MAX_NODE] octreeData;
}

layout (set = 3, binding = 0) readonly buffer GraphicPref {
	uint empty;
} graphicPref;

float getDistanceNext(in float inputFloat, in float dir, in uint voxSpan) {
	return trunc(inputFloat + (voxSpan * dir)) - inputFloat;
}

vec3 childSignToVec(in uint[3] childSign) {
	return vec3(childSign[0], childSign[1], childSign[2]);
}

vec3 getOuterPos(in vec3 innerPos, in vec3 dir, in float diameter) {
	return innerPos + (dir * diameter);
}

// 1 = inside | 0 = outside
float betweenVectorGroup(in vec3 first, in vec3 sec, in vec3 vector) {
    vec3 stepVector = step(min(first, sec), vector) - step(max(first, sec), vector);
    return stepVector.x * stepVector.y * stepVector.z;
}

float checkPosInNode(TreeNode node, vec3 checkPos) {
	vec3 bottomLeft = getOuterPos(vec3(node.X, node.Y, node.Z), vec3(-1, -1, -1), node.span / 2);
	vec3 topRight = getOuterPos(vec3(node.X, node.Y, node.Z), vec3(1, 1, 1), node.span / 2);
	
	return betweenVectorGroup(bottomLeft, topRight, checkPos);
}

uint getNextVox(in uint curIndex, in ivec3 nextPos, in vec3 dir) {
	uint[2][2][2] childPosToIndex;

	TreeNode curVox = octreeData[curIndex];

	ivec3 dirAsInt = ivec3(dir);
	int selectedDir = dirAsInt.x * 0 + dirAsInt.y * 1 + dirAsInt.z * 2;

	vec3 bottomLeft = vec3(0, 0, 0);
	vec3 topRight = vec3(0, 0, 0);
	float nextPosInParent = 0.0;
	
	uint[8][3] adjacentNodeList;
	uint adjacentNode = 0;
	
	uint curLev = 0;
	uint[uniformBuffer.maxSearchDepth] levSpaceIndex;

	for (curLev = 1; curLev < uniformBuffer.maxSearchDepth; curLev += 1) {
		nextPosInParent = checkPosInNode(curVox);
		(nextPosInParent > 0.0) ? break : (curIndex = curVox.parent, curVox = octreeData[curIndex], levSpaceIndex[curLev] = curVox.spaceIndex);
	}
	
	adjacentNode = adjacentNodeList[curLev][selectedDir];
	curIndex = octreeData[curVox.parent].children[adjacentNode];
	
	for (curLev -= 1; curLev > -1; curLev -= 1) {
		adjacentNode = adjacentNodeList[curLev][selectedDir];
		curIndex = curVox.children[adjacentNode];
	}
	
	for (int iter = 0; iter < maxSearchDepth; iter += 1) {
		if (curVox.children == [0, 0, 0, 0, 0, 0, 0, 0]) { break; }
		else {
			
		}
	}
}

void castRay(in vec2 dir, inout uint curIndex, inout vec3 curPos, out float len, out int voxAtPos) {
	float alpha = dir.x * PI / 180.0;
	float beta = dir.y * PI / 180.0;
	
	vec3 unit = vec3(abs(cos(alpha) * cos(beta)) * sign(sin(alpha)), sin(beta), abs(sin(alpha) * cos(beta)) * sign(cos(alpha)));

	vec3 distNextVox = vec3(0, 0, 0);
	vec3 lengthCertainDir = vec3(0, 0, 0);

	float selectedLen = 0;
	float inCurNode = 0;

	uint nodeWithChild = 0;

	for (int iter = 0; iter < uniformBuffer.maxRayLen; iter += 1) {
		curVox = octreeData[curIndex];
		posBefore = ivec3(curPos);

		distNextVox = vec3(getDistanceNext(curPos.x, unit.x), getDistanceNext(curPos.y, unit.y), getDistanceNext(curPos.z, unit.z));
		lengthCertainDir = vec3(abs(distNextVox.x / unit.x), abs(distNextVox.y / unit.y), abs(distNextVox.z / unit.z));

		selectedLen = min(lengthCertainDir.z, min(lengthCertainDir.x, lengthCertainDir.y));
		curPos += vec3(unit.x * selectedLen, unit.y * selectedLen, unit.z * selectedLen);

		len += selectedLen;
	
		voxAtPos = getVoxelAtPos(curPos);
		if (voxAtPos > 0) { break; }
	}
}

vec2 getFieldOfView(in vec2 imageSize) {
	return vec2((imageSize.y / imageSize.x) * uniformBuffer.rawfieldOfView, uniformBuffer.rawfieldOfView);
}

vec3 getCameraDirection(in vec2 imageSize, in vec2 pixelCoord) {
	vec2 fieldOfView = getFieldOfView(imageSize);

	float horizontalDegree = (fieldOfView.x / imageSize.x) * pixelCoord.x - fieldOfView.x / 2;
	float verticalDegree = (fieldOfView.y / imageSize.y) * pixelCoord.y - fieldOfView.y / 2;

	return vec2(horizontal, vertical);
}

void main () {
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imageSize = ivec2(gl_NumWorkGroups.xy);
	
	vec3 curPos = vec3(uniformBuffer.X, uniformBuffer.Y, uniformBuffer.Z);
	vec2 dir = getCameraDirection(vec2(imageSize * 16), vec2(pixelCoord));
	uint curIndex = uniformBuffer.nodeAtPos;
	float len = 0;
	int voxAtPos = 0;

	castRay(dir, curIndex, curPos, len, voxAtPos);

	// debugPrintfEXT("");

	if (gl_GlobalInvocationID.xy == uvec2(1,1)) {
		// debugPrintfEXT("\n%f", sin(90.0 * PI / 180.0));
	}

	imageStore(computeImage, pixelCoord, vec4(1 - len / uniformBuffer.maxRayLen, 0, 0, 0));
}
