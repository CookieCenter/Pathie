# version 450
# extension GL_ARB_separate_shader_objects : enable
# extension GL_ARB_shading_language_420pack : enable
# extension GL_EXT_debug_printf : enable

# define PI 3.141592654

# define OCTREE_MAX_NODE 2000

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

layout (set = 1, binding = 0) uniform UniformBuffer {
	uint time;

	float rawfieldOfView;
	float imgCamDistance;
	uint maxRayLen;

	float rotHorizontal;
	float rotVertical;

	uint octreeRootIndex;
	uint maxSearchDepth;
	
	uint nodeAtPos;
	float X;
	float Y;
	float Z;
} uniformBuffer;

struct TreeNode {
	uint parent;
	uint[8] children;
	uint spaceIndex;
	uint span;

	float X;
	float Y;
	float Z;
};

layout (set = 2, binding = 0) readonly buffer OctreeData {
	TreeNode[OCTREE_MAX_NODE] octreeData;
};

layout (set = 3, binding = 0) readonly buffer GraphicPref {
	uint empty;
} graphicPref;

uint posToIndex(vec3 pos, float sideLen) {
	return uint(pos.x + pos.y * sideLen * sideLen + pos.z * sideLen);
}

float getDistanceNext(in float inputFloat, in float dir, in uint voxSpan) {
	return trunc(inputFloat + (voxSpan * dir)) - inputFloat;
}

vec3 getOuterPos(in vec3 innerPos, in vec3 dir, in float diameter) {
	return innerPos + (dir * diameter);
}

// 1 = inside | 0 = outside
float inRange(in float first, in float sec, in float check) {
    float stepVector = step(min(first, sec), check) - step(max(first, sec), check);
    return stepVector.x * stepVector.y * stepVector.z;
}

// 1 = inside | 0 = outside
float betweenVectorGroup(in vec3 first, in vec3 sec, in vec3 vector) {
    vec3 stepVector = step(min(first, sec), vector) - step(max(first, sec), vector);
    return stepVector.x * stepVector.y * stepVector.z;
}

float checkPosInNode(TreeNode node, vec3 checkPos) {
	vec3 bottomLeft = getOuterPos(vec3(node.X, node.Y, node.Z), vec3(-1, -1, -1), float(node.span) / 2.0);
	vec3 topRight = getOuterPos(vec3(node.X, node.Y, node.Z), vec3(1, 1, 1), float(node.span) / 2.0);
	
	return betweenVectorGroup(bottomLeft, topRight, checkPos);
}

void updateVox(in uint nextIndex, inout uint curIndex, inout TreeNode curVox) {
	curIndex = nextIndex;
	curVox = octreeData[nextIndex];
}

uint getNextVox(in uint curIndex, in vec3 nextPos, in ivec3 dir) {
	TreeNode curVox = octreeData[curIndex];

	int selectedDir = dir.x * 0 + dir.y * 1 + dir.z * 2;

	vec3 bottomLeft = vec3(0, 0, 0);
	vec3 topRight = vec3(0, 0, 0);
	float nextPosInParent = 0.0;
	
	uint[8][3] adjacentNodeList;
	uint adjacentNode = 0;
	
	uint curLev = 0;
	uint[uniformBuffer.maxSearchDepth] levSpaceIndex;

	vec3 childPos = vec3(0, 0, 0);

	// Check if nextPos is in Parent -> If not, curVox = curVox.parent
	for (curLev = 1; curLev < uniformBuffer.maxSearchDepth; curLev += 1) {
		nextPosInParent = checkPosInNode(curVox, nextPos);
		(nextPosInParent > 0.0) ? break : (
			updateVox(curVox.parent, curIndex, curVox),
			levSpaceIndex[curLev] = curVox.spaceIndex
		);
	}
	
	// Select Unspecific Neighbor
	adjacentNode = adjacentNodeList[curVox.spaceIndex][selectedDir];
	updateVox(octreeData[curVox.parent].children[adjacentNode], curIndex, curVox);

	// Select childNode based on recent visited Level
	for (curLev -= 1; curLev > -1; curLev -= 1) {
		(curVox.children == [0, 0, 0, 0, 0, 0, 0, 0]) ? break : (
			adjacentNode = adjacentNodeList[levSpaceIndex[curLev]][selectedDir],
			updateVox(curVox.children[adjacentNode], curIndex, curVox),
		);
	}
	
	// Select childNode based on Position <- No recent visit on curLev
	for (int iter = 0; iter < maxSearchDepth; iter += 1) {
		(curVox.children == [0, 0, 0, 0, 0, 0, 0, 0]) ? break : (
			// Generate childPos -> Check in which Vox [ 0 / 1 ] nextPos is in, for each Direction
			childPos = vec3(
				inRange(curVox.x, curVox.x + float(curVox.span) / 2.0, nextPos.x)
				inRange(curVox.y, curVox.y + float(curVox.span) / 2.0, nextPos.y)
				inRange(curVox.z, curVox.z + float(curVox.span) / 2.0, nextPos.z)
			);

			updateVox(curVox.children[posToIndex(childPos)], curIndex, curVox),
		);
	}
}

void castRay(in vec2 dir, inout uint curIndex, inout vec3 curPos, out float len, out int voxAtPos) {
	// Convert Degree into Radiant
	float alpha = dir.x * PI / 180.0;
	float beta = dir.y * PI / 180.0;
	
	// Create Unit Vector with [ Time = 1 ]
	vec3 unit = vec3(abs(cos(alpha) * cos(beta)) * sign(sin(alpha)), sin(beta), abs(sin(alpha) * cos(beta)) * sign(cos(alpha)));

	vec3 distNextVox = vec3(0, 0, 0);
	vec3 lengthCertainDir = vec3(0, 0, 0);

	float selectedLen = 0;
	float inCurNode = 0;

	uint nodeWithChild = 0;

	for (int iter = 0; iter < uniformBuffer.maxRayLen; iter += 1) {
		curVox = octreeData[curIndex];
		posBefore = ivec3(curPos);

		distNextVox = vec3(getDistanceNext(curPos.x, unit.x), getDistanceNext(curPos.y, unit.y), getDistanceNext(curPos.z, unit.z));
		// Compute Time for each Direction
		lengthCertainDir = vec3(abs(distNextVox.x / unit.x), abs(distNextVox.y / unit.y), abs(distNextVox.z / unit.z));
		// Select most efficient Direction
		selectedLen = min(lengthCertainDir.z, min(lengthCertainDir.x, lengthCertainDir.y));
		// Apply Time to each Direction
		curPos += vec3(unit.x * selectedLen, unit.y * selectedLen, unit.z * selectedLen);

		len += selectedLen;
	
		voxAtPos = getVoxelAtPos(curPos);
		if (voxAtPos > 0) { break; }
	}
}

vec2 getFieldOfView(in vec2 imageSize) {
	return vec2((imageSize.y / imageSize.x) * uniformBuffer.rawfieldOfView, uniformBuffer.rawfieldOfView);
}

vec3 getCameraDirection(in vec2 imageSize, in vec2 pixelCoord) {
	vec2 fieldOfView = getFieldOfView(imageSize);

	float horizontalDegree = (fieldOfView.x / imageSize.x) * pixelCoord.x - fieldOfView.x / 2;
	float verticalDegree = (fieldOfView.y / imageSize.y) * pixelCoord.y - fieldOfView.y / 2;

	return vec2(horizontal, vertical);
}

void main () {
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imageSize = ivec2(gl_NumWorkGroups.xy);
	
	vec3 curPos = vec3(uniformBuffer.X, uniformBuffer.Y, uniformBuffer.Z);
	vec2 dir = getCameraDirection(vec2(imageSize * 16), vec2(pixelCoord));
	uint curIndex = uniformBuffer.nodeAtPos;
	float len = 0;
	int voxAtPos = 0;

	castRay(dir, curIndex, curPos, len, voxAtPos);

	// debugPrintfEXT("");

	if (gl_GlobalInvocationID.xy == uvec2(1,1)) {
		// debugPrintfEXT("\n%f", sin(90.0 * PI / 180.0));
	}

	imageStore(computeImage, pixelCoord, vec4(1 - len / uniformBuffer.maxRayLen, 0, 0, 0));
}
