# version 450
# extension GL_ARB_separate_shader_objects : enable
# extension GL_ARB_shading_language_420pack : enable
# extension GL_EXT_debug_printf : enable

# define PI 3.141592654
# define ACCURACY 100

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

layout (set = 2, binding = 0) uniform UniformBuffer {
	uint time;

	float fieldOfView;
	uint maxRayLen;	

	ivec2 headRotation;
	ivec3 playerPos;

	// uint chunkSideLen;
	// uint chunkSize;

	// uint chunkGroupSideLen;
	// uint chunkGroupSize;
} uniformBuffer;

struct VoxelChunk {
	int[512] voxelData;
};

layout (set = 1, binding = 0) buffer VoxelChunkList {
	VoxelChunk voxelChunkList[];
};

float roundFloat(float val) { return round(val * ACCURACY) / ACCURACY; }
float getDistanceNext(float input_float) { return (floor(abs(input_float) + 1) - abs(input_float)) * sign(input_float); }
uint posToIndex(ivec3 pos, int sideLength, int chunkSize) {
	int horizontal = (pos.x * sideLength);
	
	int vertical = (pos.y * sideLength * sideLength);
	int depth = (pos.z);
	return uint(horizontal + horizontal + depth + chunkSize / 2); 
}

int listIndexToPos(uint index) { return 0; }

int getVoxelAtPos(vec3 pos) {
	ivec3 posAsInt = ivec3(pos);
	// uint index = posToIndex(posAsInt, int(uniformBuffer.chunkSideLen * uniformBuffer.chunkGroupSideLen), int(uniformBuffer.chunkSize * uniformBuffer.chunkGroupSize));
	uint index = 1;
	

	// int chunkGroupLevIndex = int(index / uniformBuffer.chunkSize);
	// int chunkLevIndex = int(index / uniformBuffer.chunkGroupSize);

	return 0; // voxelChunkList[chunkGroupLevIndex].voxelData[chunkLevIndex];
}

float castRay(vec2 dir, vec3 origin) {
	float alpha = dir.x * PI / 180.0;
	float beta = dir.y * PI / 180.0;
	
	vec3 unit = vec3(cos(alpha) * cos(beta), sin(beta), sin(alpha) * cos(beta));
	
	float len = 0;
	vec3 curPos = origin;
	
	float selectedLen = 0;
	vec3 distNextVox = vec3(0, 0, 0);
	vec3 lengthCertainDir = vec3(0, 0, 0);

	for (int iter = 0; iter < uniformBuffer.maxRayLen; iter += 1) {
		distNextVox = vec3(getDistanceNext(curPos.x), getDistanceNext(curPos.y), getDistanceNext(curPos.z));
		lengthCertainDir = vec3(abs(distNextVox.x / unit.x), abs(distNextVox.y / unit.y), abs(distNextVox.z / unit.z));

		if (lengthCertainDir.x < lengthCertainDir.y) {
			if (lengthCertainDir.x < lengthCertainDir.z) {
				selectedLen = lengthCertainDir.x;
			}
			else {
				selectedLen = lengthCertainDir.z;
			} 
		}
		else {
			if (lengthCertainDir.y < lengthCertainDir.z) {
				selectedLen = lengthCertainDir.y;
			}
			else {
				selectedLen = lengthCertainDir.z;
			}
		}

		curPos += vec3(unit.x * selectedLen, unit.y * selectedLen, unit.z * selectedLen);
		len += selectedLen;

		int voxAtPos = getVoxelAtPos(curPos);
		if (voxAtPos > 0) { return len; }
	}

	return 1;
}

void main () {
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imageSize = ivec2(gl_NumWorkGroups.xy);
	
	// float degree = ((uniformBuffer.fieldOfView / float(imageSize.x * 16)) * float(pixelCoord.x)) - (uniformBuffer.fieldOfView / 2);
	
	// float test = castRay(vec2(degree, 0.0) + vec2(uniformBuffer.headRotation), vec3(0.1, 0.1, 0.1));
	// int test = getVoxelAtPos(vec3(16, 16, 16));
	debugPrintfEXT("\nt %d  f %d m %d   h %d p %d", uniformBuffer.time, uniformBuffer.fieldOfView, uniformBuffer.maxRayLen, uniformBuffer.headRotation, uniformBuffer.playerPos); // , uniformBuffer.chunkSideLen, uniformBuffer.chunkSize, uniformBuffer.chunkGroupSideLen, uniformBuffer.chunkGroupSize);
	// debugPrintfEXT("\ncl %d cs %d  cgl %d cgs %d", uniformBuffer.chunkSideLen, uniformBuffer.chunkSize, uniformBuffer.chunkGroupSideLen, uniformBuffer.chunkGroupSize);
	// imageStore(computeImage, pixelCoord, vec4(test, 0, 0, 0));	
}