# version 450
# extension GL_ARB_separate_shader_objects : enable
# extension GL_ARB_shading_language_420pack : enable
# extension GL_EXT_debug_printf : enable

# define PI 3.141592654

# define TMP_VERT_SCALE 8

# define CHUNK_SIZE 13824
# define CHUNK_SIDE_LEN 24

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

layout (set = 1, binding = 0) uniform UniformBuffer {
	uint time;

	float fieldOfView;
	uint maxRayLen;

	float rotHorizontal;
	float rotVertical;
	
	float X;
	float Y;
	float Z;
} uniformBuffer;

layout (set = 2, binding = 0) readonly buffer VoxData {
	int[CHUNK_SIZE] data[];
};

layout (set = 3, binding = 0) readonly buffer GraphicPref {
	uint empty;
} graphicPref;

float getDistanceNext(float input_float, float dir) {
	if (dir < 0.0) { return ceil(input_float - 1) - input_float; }
	else { return floor(input_float + 1) - input_float; }
}

uint posToIndex(ivec3 pos, int sideLength, int chunkSize) {
	return uint(pos.x + (pos.y * sideLength) + (pos.z * sideLength * sideLength) + (chunkSize / 2)); 
}

int getVoxelAtPos(vec3 pos) {
	ivec3 posAsInt = ivec3(pos);
	uint index = posToIndex(posAsInt, CHUNK_SIDE_LEN, CHUNK_SIZE);	

	return data[index];
}

void castRay(in vec2 dir, inout vec3 curPos, out float len, out int voxAtPos, out int test) {
	float alpha = dir.x * PI / 180.0;
	float beta = dir.y * PI / 180.0;
	
	vec3 unit = vec3(abs(cos(alpha) * cos(beta)) * sign(sin(alpha)), sin(beta), abs(sin(alpha) * cos(beta)) * sign(cos(alpha)));
	
	float selectedLen = 0;
	vec3 distNextVox = vec3(0, 0, 0);
	vec3 lengthCertainDir = vec3(0, 0, 0);

	for (int iter = 0; iter < uniformBuffer.maxRayLen; iter += 1) {
		distNextVox = vec3(getDistanceNext(curPos.x, unit.x), getDistanceNext(curPos.y, unit.y), getDistanceNext(curPos.z, unit.z));
		lengthCertainDir = vec3(abs(distNextVox.x / unit.x), abs(distNextVox.y / unit.y), abs(distNextVox.z / unit.z));

		selectedLen = min(lengthCertainDir.z, min(lengthCertainDir.x, lengthCertainDir.y));
		curPos += vec3(unit.x * selectedLen, unit.y * selectedLen, unit.z * selectedLen);

		len += selectedLen;

		if (gl_GlobalInvocationID.xy == uvec2(1,1)) {
			// debugPrintfEXT("\n%v3d", ivec3(curPos));
		}

		

		voxAtPos = getVoxelAtPos(curPos);
		if (voxAtPos > 0) { break; }

		if (ivec3(curPos) == ivec3(0,0,-6)) {
			// debugPrintfEXT("\n%d", voxAtPos);
		}
	}
}

void main () {
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imageSize = ivec2(gl_NumWorkGroups.xy);
	
	float degree = ((uniformBuffer.fieldOfView / float(imageSize.x * 16)) * float(pixelCoord.x)) - (uniformBuffer.fieldOfView / 2);

	vec3 curPos = vec3(uniformBuffer.X, uniformBuffer.Y + pixelCoord.y / TMP_VERT_SCALE, uniformBuffer.Z);
	float len = 0;
	int voxAtPos = 0;
	int test = 0;

	castRay(vec2(degree + uniformBuffer.rotHorizontal, uniformBuffer.rotVertical), curPos, len, voxAtPos, test);

	// debugPrintfEXT("");

	if (gl_GlobalInvocationID.xy == uvec2(1,1)) {
		// debugPrintfEXT("\np %v3f  l %f  v %d", curPos, len, voxAtPos);
	}

	imageStore(computeImage, pixelCoord, vec4(1 - (len / 4), 0, 0, 0));
}