# version 450
# extension GL_ARB_separate_shader_objects : enable
# extension GL_ARB_shading_language_420pack : enable
# extension GL_EXT_debug_printf : enable

# define PI 3.141592654
# define ACCURACY 100

# define CHUNK_SIZE 16

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

struct VoxelChunk {
	uint[512] voxelData;
};

layout (set = 1, binding = 0) buffer VoxelChunkList {
	VoxelChunk voxelChunkList[];
};

layout (set = 2, binding = 0) uniform UniformBuffer {
	uint time;

	float fieldOfView;
	uint maxRayLen;

	ivec2 headRotation;
	ivec3 PlayerPos;
} uniformBuffer;

float roundFloat(float val) { return round(val * ACCURACY) / ACCURACY; }
float getDistanceNext(float input_float) { return (floor(abs(input_float) + 1) - abs(input_float)) * sign(input_float); }
uint posToListIndex(ivec3 pos) { return pos.z + pos.x * CHUNK_SIZE + pos.y * CHUNK_SIZE * CHUNK_SIZE; }
int listIndexToPos(uint index) { return 0; }
float applySign(float numberToApply, float numberWithSign) { return abs(numberToApply) * sign(numberWithSign); }

float castRay(vec2 dir, vec3 origin, uint maxLen) {
	float alpha = dir.x * PI / 180.0;
	float beta = dir.y * PI / 180.0;
	
	vec3 unit = vec3(cos(alpha) * cos(beta), sin(beta), sin(alpha) * cos(beta));
	
	float len = 0;
	vec3 curPos = origin;

	for (int iter = 0; iter < maxLen; iter += 1) {
		vec3 distNextVox = vec3(getDistanceNext(curPos.x), getDistanceNext(curPos.y), getDistanceNext(curPos.z));
		vec3 lengthCertainDir = vec3(distNextVox.x / unit.x, distNextVox.y / unit.y, distNextVox.z / unit.z);

		if (abs(lengthCertainDir.x) < abs(lengthCertainDir.y)) {
			if (abs(lengthCertainDir.x) < abs(lengthCertainDir.z)) {
				float selectedLen = abs(lengthCertainDir.x);
				curPos += vec3(applySign(distNextVox.x, unit.x), unit.y * selectedLen, unit.z * selectedLen);
				len += selectedLen;
			}	
			else {
				float selectedLen = abs(lengthCertainDir.z);
				curPos += vec3(unit.x * selectedLen, unit.y * selectedLen, applySign(distNextVox.z, unit.z));
				len += selectedLen;
			} 
		}
		else {
			if (abs(lengthCertainDir.y) < abs(lengthCertainDir.z)) {
				float selectedLen = abs(lengthCertainDir.y);
				curPos += vec3(unit.x * selectedLen, applySign(distNextVox.y, unit.y), unit.z * selectedLen);
				len += selectedLen;
			}
			else {
				float selectedLen = abs(lengthCertainDir.z);
				curPos += vec3(unit.x * selectedLen, unit.y * selectedLen, applySign(distNextVox.z, unit.z));
				len += selectedLen;
			}
		}

		uint index = posToListIndex(ivec3(int(floor(curPos.x)), int(floor(curPos.y)), int(floor(curPos.z))));
		uint voxAtPos = voxelChunkList[0].voxelData[index];
		if (voxAtPos > 0) { return len * 0.2; }
	}

	return 0.0;
}

void main () {
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imageSize = ivec2(gl_NumWorkGroups.xy);
	
	float degree = uniformBuffer.fieldOfView / float(imageSize.x) * float(pixelCoord.x) - uniformBuffer.fieldOfView / 2;

	float test = castRay(vec2(degree, 0) + vec2(uniformBuffer.headRotation), vec3(0.1, 0.1, 0.1), uniformBuffer.maxRayLen);
	imageStore(computeImage, pixelCoord, vec4(test, 0, 0, 0));
}