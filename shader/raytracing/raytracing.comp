# version 450
# extension GL_ARB_separate_shader_objects : enable
# extension GL_ARB_shading_language_420pack : enable
# extension GL_EXT_debug_printf : enable

# define PI 3.141592654

# define OCTREE_MAX_NODE 2000
# define CHILD_SIGN [[-1, -1, -1], [1, -1, -1], [1, -1, 1], [-1, -1, 1], [-1, 1, -1], [1, 1, -1], [1, 1, 1], [-1, 1, 1]]

layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

layout (set = 1, binding = 0) uniform UniformBuffer {
	uint time;

	float rawfieldOfView;
	float imgCamDistance;
	uint maxRayLen;

	float rotHorizontal;
	float rotVertical;

	uint octreeRootIndex;
	uint maxSearchDepth;
	
	float X;
	float Y;
	float Z;
} uniformBuffer;

struct TreeNode {
	uint parent;
	uint[8] children;
	uint span;

	float X;
	float Y;
	float Z;
}

layout (set = 2, binding = 0) readonly buffer OctreeData {
	TreeNode[OCTREE_MAX_NODE] octreeData;
}

layout (set = 3, binding = 0) readonly buffer GraphicPref {
	uint empty;
} graphicPref;

float getDistanceNext(in float inputFloat, in float dir, in uint voxSpan) {
	if (dir < 0.0) { return ceil(inputFloat - voxSpan) - inputFloat; }
	else { return floor(inputFloat + voxSpan) - inputFloat; }
}

vec3 getOuterPos(in vec3 innerPos, in vec3 dir, in float diameter) {
	return innerPos + (dir * diameter);
}

float betweenVectorGroup(in vec3 bottomLeft, in vec3 topRight, in vec3 vector) {
    vec3 stepVector = step(bottomLeft, vector) - step(topRight, vector);
    return stepVector.x * stepVector.y * stepVector.z; 
}

vec3[2] parentCenterAndChildPos(in TreeNode parent, in uint[3] childSign, in float childDistance) {
	vec3 parentCenter = vec3(octreeData[parentIndex].X, octreeData[parentIndex].Y, octreeData[parentIndex].Z);
	vec3 childPos = getOuterPos(parentCenter, vec3(childSign[0], childSign[1], childSign[2]), childDistance);

	return [parentCenter, childPos];
}

uint chooseChildNode(in uint parentIndex, in vec3 posToCheck) {
	TreeNode parent = octreeData[parentIndex];
	float childDist = float(octreeData[parentIndex].span) / 2;

	uint selectedChild = 0;
	for (int iter = 0; iter < CHILD_SIGN.length() / 2; iter += 1) {
		vec3[2] info = parentCenterAndChildPos(parent, CHILD_SIGN[iter], childDist);
		selectedChild = iter * betweenVectorGroup(info[0], infop[1], posToCheck);
	}

	for (int iter = CHILD_SIGN.length() / 2; iter < CHILD_SIGN.length(); iter += 1) {
		vec3[2] info = parentCenterAndChildPos(parent, CHILD_SIGN[iter], childDist);
		selectedChild = iter * betweenVectorGroup(info[1], infop[0], posToCheck);
	}

	return selectedChild;
}

int getVoxelAtPos(in uint rootIndex, in vec3 voxPos, in uint maxSearchDepth) {
	uint curIndex = rootIndex;
	for (int iter = 0; iter < maxSearchDepth; iter += 1) {
		
	}
}

void castRay(in vec2 dir, inout vec3 curPos, out float len, out int voxAtPos, out int test) {
	float alpha = dir.x * PI / 180.0;
	float beta = dir.y * PI / 180.0;
	
	vec3 unit = vec3(abs(cos(alpha) * cos(beta)) * sign(sin(alpha)), sin(beta), abs(sin(alpha) * cos(beta)) * sign(cos(alpha)));
	
	float selectedLen = 0;
	vec3 distNextVox = vec3(0, 0, 0);
	vec3 lengthCertainDir = vec3(0, 0, 0);

	for (int iter = 0; iter < uniformBuffer.maxRayLen; iter += 1) {
		distNextVox = vec3(getDistanceNext(curPos.x, unit.x), getDistanceNext(curPos.y, unit.y), getDistanceNext(curPos.z, unit.z));
		lengthCertainDir = vec3(abs(distNextVox.x / unit.x), abs(distNextVox.y / unit.y), abs(distNextVox.z / unit.z));

		selectedLen = min(lengthCertainDir.z, min(lengthCertainDir.x, lengthCertainDir.y));
		curPos += vec3(unit.x * selectedLen, unit.y * selectedLen, unit.z * selectedLen);

		len += selectedLen;

		voxAtPos = getVoxelAtPos(curPos);
		if (voxAtPos > 0) { break; }
	}
}

vec2 getFieldOfView(in vec2 imageSize) {
	return vec2((imageSize.y / imageSize.x) * uniformBuffer.rawfieldOfView, uniformBuffer.rawfieldOfView);
}

vec3 getCameraDirection(in vec2 imageSize, in vec2 pixelCoord) {
	vec2 fieldOfView = getFieldOfView(imageSize);

	float horizontalDegree = (fieldOfView.x / imageSize.x) * pixelCoord.x - fieldOfView.x / 2;
	float verticalDegree = (fieldOfView.y / imageSize.y) * pixelCoord.y - fieldOfView.y / 2;

	return vec2(horizontal, vertical);
}

void main () {
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imageSize = ivec2(gl_NumWorkGroups.xy);
	
	vec3 curPos = vec3(uniformBuffer.X, uniformBuffer.Y, uniformBuffer.Z);
	vec2 dir = getCameraDirection(vec2(imageSize * 16), vec2(pixelCoord));
	float len = 0;
	int voxAtPos = 0;
	int test = 0;

	castRay(dir, curPos, len, voxAtPos, test);

	// debugPrintfEXT("");

	if (gl_GlobalInvocationID.xy == uvec2(1,1)) {
		// debugPrintfEXT("\n%f", sin(90.0 * PI / 180.0));
	}

	imageStore(computeImage, pixelCoord, vec4(1 - len / uniformBuffer.maxRayLen, 0, 0, 0));
}