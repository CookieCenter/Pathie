# version 450
# extension GL_ARB_separate_shader_objects : enable
# extension GL_ARB_shading_language_420pack : enable
# extension GL_EXT_debug_printf : enable

# define MAX 100
# define PI 3.141592654
# define LIMIT 100
# define ACCURACY 100
# define FOV 60

layout (local_size_x = 5, local_size_y = 5) in;
layout (set = 0, binding = 0, rgba8) uniform image2D computeImage;

struct BasicVoxel {
	bool valid;
	vec4 color;
};

layout (set = 1, binding = 0) buffer BasicVoxelList {
	BasicVoxel basicVoxelList[];
};

layout (set = 2, binding = 0) buffer UniformBuffer {
	vec3 headRotation;
	vec3 PlayerPos;
} uniformBuffer;

BasicVoxel[32][32][32] voxelMatrix;

float roundFloat(float val) { return round(val * ACCURACY) / ACCURACY; }
float getDistanceNext(float input_float) { return floor(input_float + sign(input_float)) - (input_float * sign(input_float)); }
float divide(float first, float sec) { if (sec != 0.0) { return first / sec; } else { return first; } }

BasicVoxel castRay(vec2 dir, vec3 origin) {
	float alpha = dir.x * PI / 180;
	float beta = dir.y * PI / 180;
	vec3 unit = vec3(cos(alpha) * cos(beta), sin(beta), sin(alpha) * cos(beta));
	
	float len = 0;
	vec3 curPos = origin;
	BasicVoxel voxel = BasicVoxel(false, vec4(0.0, 0.0, 0.0, 0.0));
	
	for (int iter = 0; iter < LIMIT; iter += 1) {
		vec3 distNextVox = vec3(getDistanceNext(curPos.x), getDistanceNext(curPos.y), getDistanceNext(curPos.z));
		vec3 lengthCertainDir = vec3(distNextVox.x / unit.x, distNextVox.y / unit.y, distNextVox.z / unit.z);

		if (lengthCertainDir.x < lengthCertainDir.y) {
			if (lengthCertainDir.x < lengthCertainDir.z) {
				float selectedLen = lengthCertainDir.x;
				curPos = vec3(curPos.x + distNextVox.y, unit.y * selectedLen + curPos.y, unit.z * selectedLen + curPos.z);
				len += selectedLen;
			}	
			else {
				float selectedLen = lengthCertainDir.z;
				curPos = vec3(unit.x * selectedLen + curPos.x, unit.y * selectedLen + curPos.y, curPos.z + distNextVox.z);
				len += selectedLen;
			} 
		}
		else {
			if (lengthCertainDir.y < lengthCertainDir.z) {
				float selectedLen = lengthCertainDir.y;
				curPos = vec3(unit.x * selectedLen + curPos.x, curPos.y + distNextVox.y, unit.z * selectedLen + curPos.z);
				len += selectedLen;
			}
			else {
				float selectedLen = lengthCertainDir.z;
				curPos = vec3(unit.x * selectedLen + curPos.x, unit.y * selectedLen + curPos.y, curPos.z + distNextVox.z);
				len += selectedLen;
			}
		}

		ivec3 curPosInt = ivec3(int(floor(curPos.x)), int(floor(curPos.y)), int(floor(curPos.z)));
		BasicVoxel currentVoxel = voxelMatrix[curPosInt.x][curPosInt.y][curPosInt.z];
		if (currentVoxel.valid == true) { voxel = currentVoxel; break; }
	}
	
	return voxel;
}

void main () {
	voxelMatrix[3][3][3] = BasicVoxel(true, vec4(1, 0, 0, 0));

	ivec2 workPos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 groupCount = ivec2(gl_NumWorkGroups.xy);

	vec2 workPosVec = vec2(workPos);
	vec2 groupCountVec = vec2(groupCount);

	if (workPos.x == 1 && workPos.y == 1) {
		debugPrintfEXT("\n%v2f", groupCountVec);
	}

	float degree = (60.0 / 800.0); 
	
	BasicVoxel test = castRay(vec2(degree, 35), vec3(0.1, 0.1, 0.1));

	// debugPrintfEXT("\n%f", gl_GlobalInvocationID.xy.x);
	
	imageStore(computeImage, workPos, test.color);
}